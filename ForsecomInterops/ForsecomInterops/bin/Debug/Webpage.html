<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <title></title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://unpkg.com/vuex"></script>
    <!-- Script for polyfilling Promises on IE9 and 10 -->
    <!-- see: https://github.com/vuejs-templates/webpack/issues/474 -->
    <script src='https://cdn.polyfill.io/v2/polyfill.min.js'></script>
</head>
<body>
    <div id="app">
        <button v-on:click="checkDate">Check Date</button>

        <button v-on:click="phoneHome">
            This is a JS button in the webpage!
        </button> <br />

        Last time active: ({{ lastDate }}) <br />
        Time since last active: {{ timeElapsed }} minutes <br />
        {{ message }}
    </div>
    <script>
        function test(message) { return app.test(message) }
        function setDate(date) { return app.setDate(date) }

        Vue.use(Vuex)
        const store = new Vuex.Store({
            // Global state store
            state: {
                lastDate: null,
                timeElapsed: null
            },
            // Mutations update the state
            // All-caps is convention for the names of mutations, actions, and getters
            mutations: {
                UPDATE_LAST_DATE: function (state, date) {
                    state.lastDate = date;
                },
                UPDATE_ELAPSED_TIME: function (state) {
                    state.timeElapsed = ((Date.now() - Date.parse(state.lastDate))/60000).toFixed(2);
                }
            }
        })

        var app = new Vue({
            el: '#app',
            // The store has to be injected into the Vue instance
            store: store,
            data: {
                message: 'If you see me, vue is working!',
                dateCheck: false,
            },
            computed: {
                // References the lastDate in the global store
                // These are "computed" properties and not "data" because they rely on the global store's state
                lastDate: function () {
                    return this.$store.state.lastDate;
                },
                timeElapsed: function () {
                    return this.$store.state.timeElapsed;
                }
                // Declaring each global state value we need for this component separately is a pain, but for some reason 
                // I can't get '...mapState()' (Vue's suggested solution) to work in our setup
            },
            methods: {
                updateDateCheck: function (status) {
                    this.dateCheck = status;
                },
                checkDate: function () {
                    window.external.requestLastActiveTime();
                },
                // Updates the lastDate value in the global store
                setDate: function (date) {
                    this.$store.commit('UPDATE_LAST_DATE', date);
                },
                test: function (message) { alert(message); return "This is some return data originating from the JS side of things"; },
                phoneHome: function () {
                    window.external.SendInfoToWindows('Some JS message');
                },
                updateTimeElapsed: function () {
                    this.$store.commit('UPDATE_ELAPSED_TIME');
                }
            },
            // These two intervals on mounted() and beforeDestroy() ensure that the global timeElapsed is updated regularly - normally, Vue reactively updates fields as 
            // needed (and caches the last result), but in the specific case of using Date.now(), Vue can't tell that it changes every time you call it, so we have to manually tell it to update.
            // (as per here: https://medium.com/vuejs-tips/i-want-it-now-ca6c89dded6c and https://cushionapp.com/journal/reactive-time-with-vuejs)
            mounted: function () {
                this.$options.interval = setInterval(this.updateTimeElapsed, 1000); // We update every second
            },
            beforeDestroy: function () {
                clearInterval(this.$options.interval);
            }
        })

    </script>
</body>
</html>